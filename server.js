// ÌôòÍ≤ΩÎ≥ÄÏàò ÏÑ§Ï†ï
require('dotenv').config();

// ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú ÌÖåÏä§Ìä∏
console.log('=== ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú ÌÖåÏä§Ìä∏ ===');
console.log('DROPBOX_TOKEN:', process.env.DROPBOX_TOKEN ? 'ÏÑ§Ï†ïÎê®' : 'ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå');
console.log('DROPBOX_REFRESH_TOKEN:', process.env.DROPBOX_REFRESH_TOKEN ? 'ÏÑ§Ï†ïÎê®' : 'ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå');
console.log('DROPBOX_CLIENT_ID:', process.env.DROPBOX_CLIENT_ID ? 'ÏÑ§Ï†ïÎê®' : 'ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå');
console.log('DROPBOX_CLIENT_SECRET:', process.env.DROPBOX_CLIENT_SECRET ? 'ÏÑ§Ï†ïÎê®' : 'ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå');
console.log('========================');

const express = require('express');
const puppeteer = require('puppeteer');
const sqlite3 = require('sqlite3');
const cors = require('cors');
const path = require('path');
const cron = require('node-cron');
const ExcelJS = require('exceljs');
const fs = require('fs');
const compression = require('compression');
const { Dropbox } = require('dropbox');
const axios = require('axios');
const { promisify } = require('util');

const app = express();
const port = process.env.PORT || 5001;

// Render Î∞∞Ìè¨ Í∞êÏßÄ Î∞è ÌôòÍ≤Ω ÏÑ§Ï†ï
const IS_RENDER = process.env.RENDER === 'true';
const RENDER_EXTERNAL_URL = process.env.RENDER_EXTERNAL_URL;

// Puppeteer Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨ ÏÑ§Ï†ï
const tmpCachePath = '/tmp/puppeteer';
process.env.PUPPETEER_CACHE_DIR = tmpCachePath;

if (!fs.existsSync(tmpCachePath)) {
    fs.mkdirSync(tmpCachePath, { recursive: true });
    console.log(`‚úÖ Puppeteer Ï∫êÏãú Í≤ΩÎ°ú ÏÉùÏÑ±Îê®: ${tmpCachePath}`);
}

// Í∏∞Î≥∏ ÏÑ§Ï†ï
app.use(compression());
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public'), { maxAge: '1d' }));

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ï
const DB_MAIN_FILE = 'rankings.db';
const DB_BACKUP_DIR = path.join(__dirname, 'backups');
const DROPBOX_CAPTURES_PATH = '/olive_rankings/captures';

// Î∞±ÏóÖ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
if (!fs.existsSync(DB_BACKUP_DIR)) {
    fs.mkdirSync(DB_BACKUP_DIR, { recursive: true });
}

// Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
let dropboxClient = null;
if (process.env.DROPBOX_TOKEN) {
    try {
        dropboxClient = new Dropbox({
            accessToken: process.env.DROPBOX_TOKEN
        });
        console.log('‚úÖ Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.');
    } catch (error) {
        console.error('‚ùå Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error.message);
    }
} else {
    console.warn('‚ö†Ô∏è Dropbox Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏäµÎãàÎã§. Dropbox Î∞±ÏóÖÏù¥ ÎπÑÌôúÏÑ±ÌôîÎê©ÎãàÎã§.');
}

// Dropbox Ìè¥Îçî Ï¥àÍ∏∞Ìôî
if (dropboxClient) {
    [DROPBOX_CAPTURES_PATH, '/olive_rankings/backup'].forEach(folder => {
        dropboxClient.filesCreateFolderV2({ path: folder, autorename: false })
        .then(() => console.log(`‚úÖ Dropbox Ìè¥Îçî ÏÉùÏÑ± ÏôÑÎ£å: ${folder}`))
        .catch(err => {
            if (err.status === 409 || (err.error_summary && err.error_summary.startsWith('path/conflict/folder'))) {
                console.log(`‚úÖ Dropbox Ìè¥ÎçîÍ∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï©ÎãàÎã§: ${folder}`);
            } else {
                console.error(`‚ùå Dropbox Ìè¥Îçî ÏÉùÏÑ± Ï§ë Ïò§Î•ò (${folder}):`, err);
            }
        });
    });
}

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞
const db = new sqlite3.Database(DB_MAIN_FILE, (err) => {
    if (err) console.error('DB error:', err.message);
    console.log('Connected to SQLite');
});

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨Î•º PromiseÎ°ú ÎûòÌïë
const dbRun = promisify(db.run.bind(db));
const dbAll = promisify(db.all.bind(db));
const dbGet = promisify(db.get.bind(db));

// ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî
db.serialize(() => {
    // rankings ÌÖåÏù¥Î∏î
    db.run(`
        CREATE TABLE IF NOT EXISTS rankings (
            date TEXT,
            rank INTEGER,
            brand TEXT,
            product TEXT,
            salePrice TEXT,
            originalPrice TEXT,
            event TEXT,
            category TEXT,
            PRIMARY KEY (date, category, rank)
        );
    `);

    // update_logs ÌÖåÏù¥Î∏î
    db.run(`
        CREATE TABLE IF NOT EXISTS update_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            updated_at TEXT DEFAULT (datetime('now', 'localtime'))
        );
    `);

    // captures ÌÖåÏù¥Î∏î
    db.run(`
        CREATE TABLE IF NOT EXISTS captures (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            filename TEXT NOT NULL,
            category TEXT NOT NULL,
            capture_date TEXT NOT NULL,
            dropbox_path TEXT,
            created_at TEXT DEFAULT (datetime('now', 'localtime'))
        );
    `);

    // backup_logs ÌÖåÏù¥Î∏î
    db.run(`
        CREATE TABLE IF NOT EXISTS backup_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            backup_file TEXT NOT NULL,
            backup_date TEXT NOT NULL,
            dropbox_path TEXT,
            is_success BOOLEAN DEFAULT 1,
            error_message TEXT,
            created_at TEXT DEFAULT (datetime('now', 'localtime'))
        );
    `);
});

// Ïπ¥ÌÖåÍ≥†Î¶¨ Îß§Ìïë
const oliveYoungCategories = {
    Ïä§ÌÇ®ÏºÄÏñ¥: '10000010001',
    ÎßàÏä§ÌÅ¨Ìå©: '10000010009',
    ÌÅ¥Î†åÏßï: '10000010010',
    ÏÑ†ÏºÄÏñ¥: '10000010011',
    Î©îÏù¥ÌÅ¨ÏóÖ: '10000010002',
    ÎÑ§Ïùº: '10000010012',
    Î∑∞Ìã∞ÏÜåÌíà: '10000010006',
    ÎçîÎ™®_ÏΩîÏä§Î©îÌã±: '10000010008',
    Îß®Ï¶àÏºÄÏñ¥: '10000010007',
    Ìñ•Ïàò_ÎîîÌì®Ï†Ä: '10000010005',
    Ìó§Ïñ¥ÏºÄÏñ¥: '10000010004',
    Î∞îÎîîÏºÄÏñ¥: '10000010003',
    Í±¥Í∞ïÏãùÌíà: '10000020001',
    Ìë∏Îìú: '10000020002',
    Íµ¨Í∞ïÏö©Ìíà: '10000020003',
    Ìó¨Ïä§_Í±¥Í∞ïÏö©Ìíà: '10000020005',
    Ïó¨ÏÑ±_ÏúÑÏÉùÏö©Ìíà: '10000020004',
    Ìå®ÏÖò: '10000030007',
    Î¶¨Îπô_Í∞ÄÏ†Ñ: '10000030005',
    Ï∑®ÎØ∏_Ìå¨Ïãú: '10000030006'
};

// Í∞ÄÍ≤© Ï†ïÍ∑úÌôî Ìï®Ïàò
function normalizePrice(price) {
    if (!price || price === '-' || price === 'X') return price;
    
    let normalized = price
        .replace(/\n/g, '')
        .replace(/\r/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    
    normalized = normalized
        .replace(/(\d)\s+(\d)/g, '$1$2')
        .replace(/(\d+)\s*Ïõê/g, '$1Ïõê')
        .replace(/(\d+),(\d+)Ïõê/g, '$1$2Ïõê')
        .replace(/(\d+),(\d+),(\d+)Ïõê/g, '$1$2$3Ïõê');
    
    if (normalized.match(/^\d+$/)) {
        normalized += 'Ïõê';
    }
    
    return normalized;
}

// Chrome Î∞îÏù¥ÎÑàÎ¶¨ Í≤ΩÎ°ú ÏûêÎèô ÌÉêÏßÄ
function getChromeBinaryPath() {
    try {
        const localRoot = path.join(__dirname, 'chromium');
        if (fs.existsSync(localRoot)) {
            const localVersions = fs.readdirSync(localRoot);
            for (const ver of localVersions) {
                const base = path.join(localRoot, ver);
                const candidate = path.join(base, 'chrome-linux64', 'chrome');
                if (fs.existsSync(candidate)) return candidate;
                const candidate2 = path.join(base, 'chrome');
                if (fs.existsSync(candidate2)) return candidate2;
            }
        }
    } catch (e) {
        console.warn('Î°úÏª¨ chromium ÌÉêÏßÄ Ïã§Ìå®:', e.message);
    }
    
    try {
        const chromeRoot = path.join(process.env.PUPPETEER_CACHE_DIR, 'chrome');
        const versions = fs.readdirSync(chromeRoot);
        for (const ver of versions) {
            const base = path.join(chromeRoot, ver);
            const candidate = path.join(base, 'chrome-linux64', 'chrome');
            if (fs.existsSync(candidate)) return candidate;
            const candidate2 = path.join(base, 'chrome');
            if (fs.existsSync(candidate2)) return candidate2;
        }
    } catch (e) {
        console.warn('Puppeteer Ï∫êÏãú chrome ÌÉêÏßÄ Ïã§Ìå®:', e.message);
    }
    
    return puppeteer.executablePath();
}

const CHROME_PATH = process.env.CHROME_PATH || getChromeBinaryPath();
console.log('‚ñ∂Ô∏è Using Chrome executable:', CHROME_PATH);

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ Í∏∞Îä•
async function backupDatabase() {
    try {
        const now = new Date();
        const timestamp = now.toISOString().replace(/[:.]/g, '-');
        const backupFileName = `rankings_${timestamp}.db`;
        const backupPath = path.join(DB_BACKUP_DIR, backupFileName);
        
        console.log(`üîÑ DB Î∞±ÏóÖ ÏãúÏûë: ${backupFileName}`);
        
        // Í∏∞Ï°¥ DB ÌååÏùº Î≥µÏÇ¨
        await new Promise((resolve, reject) => {
            const readStream = fs.createReadStream(DB_MAIN_FILE);
            const writeStream = fs.createWriteStream(backupPath);
            
            readStream.on('error', (error) => reject(error));
            writeStream.on('error', (error) => reject(error));
            writeStream.on('finish', () => resolve());
            
            readStream.pipe(writeStream);
        });
        
        console.log(`‚úÖ Î°úÏª¨ Î∞±ÏóÖ ÏôÑÎ£å: ${backupPath}`);
        
        // DropboxÏóê ÏóÖÎ°úÎìú
        let dropboxPath = null;
        if (dropboxClient) {
            try {
                const dropboxFilePath = `/olive_rankings/backup/${backupFileName}`;
                const fileContent = fs.readFileSync(backupPath);
                
                await dropboxClient.filesUpload({
                    path: dropboxFilePath,
                    contents: fileContent,
                    mode: {'.tag': 'overwrite'}
                });
                
                console.log(`‚úÖ Dropbox Î∞±ÏóÖ ÏôÑÎ£å: ${dropboxFilePath}`);
                dropboxPath = dropboxFilePath;
                
            } catch (error) {
                if (error.error && error.error['.tag'] === 'expired_access_token') {
                    console.error('‚ùå Dropbox access token expired. Please renew DROPBOX_TOKEN.');
                    dropboxClient = null;
                } else {
                    console.error('‚ùå Dropbox Î∞±ÏóÖ Ïã§Ìå®:', error);
                }
                await dbRun(
                    `INSERT INTO backup_logs (backup_file, backup_date, dropbox_path, is_success, error_message)
                    VALUES (?, ?, ?, ?, ?)`,
                    [backupFileName, now.toISOString(), null, 0, error.message]
                );
                return false;
            }
        }
        
        // ÏÑ±Í≥µ Î°úÍ∑∏ Í∏∞Î°ù
        await dbRun(
            `INSERT INTO backup_logs (backup_file, backup_date, dropbox_path, is_success) 
            VALUES (?, ?, ?, ?)`,
            [backupFileName, now.toISOString(), dropboxPath, 1]
        );
        
        return true;
    } catch (error) {
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖ Í≥ºÏ†ïÏóêÏÑú Ïò§Î•ò Î∞úÏÉù:', error);
        return false;
    }
}

// ÌÅ¨Î°§ÎßÅÌïú Îç∞Ïù¥ÌÑ∞Î•º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
async function saveProductsToDB(products, category, date) {
    if (!products || products.length === 0) {
        console.warn(`${category} Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.`);
        return;
    }

    const normalizedProducts = products.map((item, index) => ({
        category,
        rank: index + 1,
        brand: item.brand || '',
        product: item.product || '',
        salePrice: item.salePrice || '',
        originalPrice: item.originalPrice || '',
        event: item.event || ''
    }));

    try {
        await dbRun('BEGIN TRANSACTION');

        const stmt = db.prepare(`
            INSERT OR REPLACE INTO rankings (date, category, rank, brand, product, salePrice, originalPrice, event)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `);

        for (const item of normalizedProducts) {
            await new Promise((resolve, reject) => {
                stmt.run(
                    date,
                    item.category,
                    item.rank,
                    item.brand,
                    item.product,
                    item.salePrice,
                    item.originalPrice,
                    item.event,
                    (err) => {
                        if (err) reject(err);
                        else resolve();
                    }
                );
            });
        }

        stmt.finalize();
        await dbRun('COMMIT');
        console.log(`‚úÖ ${category} Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å`);
    } catch (error) {
        console.error(`‚ùå ${category} Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïã§Ìå®:`, error);
        await dbRun('ROLLBACK');
        throw error;
    }
}

// ÌÅ¨Î°§ÎßÅ Ìï®Ïàò
async function crawlOliveYoung(category) {
    let products = [];
    let browser;

    console.log(`${category} ÌÅ¨Î°§ÎßÅ Ï§ë...`);

    try {
        browser = await puppeteer.launch({
            executablePath: CHROME_PATH,
            headless: 'new',
            args: [
                '--no-sandbox', 
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-accelerated-2d-canvas',
                '--disable-gpu',
                '--disable-extensions',
                '--disable-audio-output',
                '--js-flags=--max-old-space-size=512'
            ],
            timeout: 30000
        });

        const page = await browser.newPage();
        
        // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Î∂àÌïÑÏöîÌïú Î¶¨ÏÜåÏä§ Ï∞®Îã®
        await page.setRequestInterception(true);
        page.on('request', req => {
            const t = req.resourceType();
            if (['image','font','media','stylesheet'].includes(t)) req.abort();
            else req.continue();
        });
        
        // Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ï
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36');
        await page.setJavaScriptEnabled(true);
        await page.setExtraHTTPHeaders({ 
            'accept-language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'
        });
        
        await page.setDefaultNavigationTimeout(30000);
        await page.setDefaultTimeout(30000);

        const baseUrl = 'https://www.oliveyoung.co.kr/store/main/getBestList.do';
        const categoryCode = oliveYoungCategories[category];
        const url = `${baseUrl}?dispCatNo=900000100100001&fltDispCatNo=${categoryCode}&pageIdx=1&rowsPerPage=100`;

        await page.goto(url, {
            waitUntil: 'domcontentloaded',
            timeout: 60000
        });

        try {
            await page.waitForSelector('.prd_info', { timeout: 30000 });
        } catch (err) {
            console.warn(`${category} ÏÉÅÌíà Î™©Î°ù Î°úÎî© ÏßÄÏó∞: ${err.message}. Í≥ÑÏÜç ÏßÑÌñâÌï©ÎãàÎã§.`);
        }

        products = await page.evaluate((cat) => {
            const result = [];
            const items = document.querySelectorAll('.prd_info');
            
            if (!items || items.length === 0) {
                return result;
            }
        
            items.forEach((el, index) => {
                try {
                    const brand = el.querySelector('.tx_brand')?.innerText.trim() || '';
                    const product = el.querySelector('.tx_name')?.innerText.trim() || '';
                    let salePrice = el.querySelector('.prd_price .tx_cur .tx_num')?.innerText.trim() || 'X';
                    let originalPrice = el.querySelector('.tx_org .tx_num')?.innerText.trim() || 'X';
        
                    salePrice = salePrice !== 'X' ? salePrice.replace(/\n/g, '').replace(/\s+/g, ' ').replace('Ïõê', '').trim() + 'Ïõê' : salePrice;
                    originalPrice = originalPrice !== 'X' ? originalPrice.replace(/\n/g, '').replace(/\s+/g, ' ').replace('Ïõê', '').trim() + 'Ïõê' : originalPrice;
        
                    if (salePrice === 'X' && originalPrice !== 'X') {
                        salePrice = originalPrice;
                    } else if (originalPrice === 'X' && salePrice !== 'X') {
                        originalPrice = salePrice;
                    }
        
                    const eventFlags = Array.from(el.querySelectorAll('.icon_flag'))
                        .map(flag => flag.textContent.trim())
                        .join(' / ') || 'X';
        
                    result.push({
                        rank: index + 1,
                        category: cat,
                        brand,
                        product,
                        salePrice,
                        originalPrice,
                        event: eventFlags
                    });
                } catch (error) {
                    console.error(`ÏÉÅÌíà Ï†ïÎ≥¥ Ï∂îÏ∂ú Ï§ë Ïò§Î•ò(${index+1}Î≤àÏß∏): ${error.message}`);
                }
            });
            return result;
        }, category);
        
        if (products.length === 0) {
            throw new Error(`${category} ÏÉÅÌíà Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
        }
    
        const now = new Date();
        const koreaTime = new Date(now.getTime() + 9 * 60 * 60 * 1000);
        const date = koreaTime.toISOString().split('T')[0];

        await saveProductsToDB(products, category, date);
        console.log(`‚úÖ ${category} ÌÅ¨Î°§ÎßÅ ÏÑ±Í≥µ: ${products.length}Í∞ú ÏÉÅÌíà`);
    
    } catch (err) {
        console.error(`‚ùå ${category} ÌÅ¨Î°§ÎßÅ Ïã§Ìå®:`, err.message);
        return [];
    } finally {
        if (browser) {
            try {
                await browser.close();
            } catch (error) {
                console.error('Î∏åÎùºÏö∞Ï†Ä Ï¢ÖÎ£å Ïò§Î•ò:', error.message);
            }
        }
    }
    return products;
}

// ÎßàÏßÄÎßâ ÌÅ¨Î°§ÎßÅ ÏãúÍ∞Å Ï†ÄÏû•
function saveLastCrawled() {
    const now = new Date().toISOString();
    db.run(
        `INSERT OR REPLACE INTO update_logs (updated_at) VALUES (?)`,
        [now],
        (err) => {
            if (err) {
                console.error('ÎßàÏßÄÎßâ ÌÅ¨Î°§ÎßÅ ÏãúÍ∞Å Ï†ÄÏû• Ï§ë Ïò§Î•ò:', err);
            }
        }
    );
}

// Î™®Îì† Ïπ¥ÌÖåÍ≥†Î¶¨ ÌÅ¨Î°§ÎßÅ
async function crawlAllCategories() {
    const today = new Date().toISOString().split('T')[0];
    console.log(`üìä ${today} - Î™®Îì† Ïπ¥ÌÖåÍ≥†Î¶¨ ÌÅ¨Î°§ÎßÅ ÏãúÏûë`);
    
    const categories = Object.keys(oliveYoungCategories);
    const results = [];
    
    for (const category of categories) {
        console.log(`üîÑ ${category} ÌÅ¨Î°§ÎßÅ ÏãúÏûë`);
        const res = await crawlOliveYoung(category);
        results.push(res);
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    const successCount = results.filter(r => Array.isArray(r) && r.length > 0).length;
    console.log(`‚ú® ${today} - Î™®Îì† Ïπ¥ÌÖåÍ≥†Î¶¨ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å: ÏÑ±Í≥µ ${successCount}/${categories.length}`);
    
    saveLastCrawled();
    return true;
}

// ÏÑúÎ≤Ñ URL Í∞ÄÏ†∏Ïò§Í∏∞
const getServerUrl = () => {
    if (IS_RENDER && RENDER_EXTERNAL_URL) {
        return RENDER_EXTERNAL_URL;
    }
    return `http://localhost:${port}`;
};

// ÏÑúÎ≤Ñ Ïä¨Î¶Ω Î∞©ÏßÄ Ìïë ÏÑ§Ï†ï
const setupAntiSleepPing = () => {
    const PING_INTERVAL = 5 * 60 * 1000; // 5Î∂Ñ
    
    setInterval(async () => {
        const serverUrl = getServerUrl();
        try {
            console.log(`üîÑ ÏÑúÎ≤Ñ Ïä¨Î¶Ω Î∞©ÏßÄ ping Ïã§Ìñâ... (${new Date().toISOString()})`);
            const response = await axios.get(`${serverUrl}/ping`);
            console.log(`‚úÖ Ping ÏÑ±Í≥µ: ${response?.data || 'OK'}`);
        } catch (error) {
            console.error(`‚ùå Ping Ïã§Ìå® (${serverUrl}/ping):`, error.message);
        }
    }, PING_INTERVAL);
    
    console.log(`‚è∞ ÏÑúÎ≤Ñ Ïä¨Î¶Ω Î∞©ÏßÄ Í∏∞Îä• ÌôúÏÑ±Ìôî: ${PING_INTERVAL/1000}Ï¥à Í∞ÑÍ≤©`);
};

// ÏÑúÎ≤Ñ ÏãúÏûë
app.listen(port, () => {
    console.log(`üì° ÏÑúÎ≤ÑÍ∞Ä http://localhost:${port} ÏóêÏÑú Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.`);
    
    setupAntiSleepPing();
    
    console.log('üîÑ ÏÑúÎ≤Ñ ÏãúÏûë Ïãú ÏûêÎèô ÌÅ¨Î°§ÎßÅ Ïã§Ìñâ Ï§ë...');
    crawlAllCategories().then(() => {
        console.log('‚úÖ Ï¥àÍ∏∞ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å');
        return backupDatabase();
    }).then((backupResult) => {
        if (backupResult) {
            console.log('‚úÖ ÏÑúÎ≤Ñ ÏãúÏûë Ïãú DB Î∞±ÏóÖ ÏôÑÎ£å');
        }
        
        if (dropboxClient) {
            return dbAll(`SELECT COUNT(*) as count FROM captures WHERE dropbox_path IS NULL`);
        }
    }).then(result => {
        if (result && result[0] && result[0].count > 0) {
            console.log(`üîÑ ÎØ∏ÏóÖÎ°úÎìú Ï∫°Ï≤ò Ïù¥ÎØ∏ÏßÄ ${result[0].count}Í∞ú Î∞úÍ≤¨. ÏûêÎèô ÏóÖÎ°úÎìú ÏãúÏûë...`);
            const serverUrl = getServerUrl();
            axios.post(`${serverUrl}/api/captures/upload-to-dropbox`)
                .catch(err => console.error('Ï∫°Ï≤ò ÏûêÎèô ÏóÖÎ°úÎìú ÏöîÏ≤≠ Ïã§Ìå®:', err));
        }
    }).catch(err => {
        console.error('‚ùå Ï¥àÍ∏∞ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:', err);
    });
    
    // Îß§Ïùº Ïò§Ï†Ñ 9Ïãú ÌÅ¨Î°§ÎßÅ
    cron.schedule('0 9 * * *', async () => {
        console.log('‚è∞ ÏòàÏïΩÎêú ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏãúÏûë - Ïò§Ï†Ñ 9Ïãú');
        try {
            const serverUrl = getServerUrl();
            await axios.get(`${serverUrl}/api/wake-up?run_tasks=true`);
            
            await crawlAllCategories();
            console.log('‚úÖ ÏòàÏïΩÎêú ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏôÑÎ£å');
            
            const backupResult = await backupDatabase();
            if (backupResult) {
                console.log('‚úÖ ÏòàÏïΩÎêú DB Î∞±ÏóÖ ÏôÑÎ£å');
            }
        } catch (error) {
            console.error('‚ùå ÏòàÏïΩÎêú ÏûëÏóÖ Ï§ë Ïò§Î•ò:', error);
        }
    }, {
        timezone: 'Asia/Seoul'
    });
    
    // Îß§Ïùº Î∞§ 12Ïãú DB Î∞±ÏóÖ
    cron.schedule('0 0 * * *', async () => {
        console.log('‚è∞ ÏòàÏïΩÎêú Î∞±ÏóÖ ÏûëÏóÖ ÏãúÏûë - Î∞§ 12Ïãú');
        try {
            const serverUrl = getServerUrl();
            await axios.get(`${serverUrl}/api/wake-up`);
            
            const backupResult = await backupDatabase();
            if (backupResult) {
                console.log('‚úÖ ÏòàÏïΩÎêú DB Î∞±ÏóÖ ÏôÑÎ£å');
            } else {
                console.error('‚ùå Î∞±ÏóÖ Ïã§Ìå®');
            }
            
            if (dropboxClient) {
                const result = await dbAll(`SELECT COUNT(*) as count FROM captures WHERE dropbox_path IS NULL`);
                if (result[0].count > 0) {
                    console.log(`üîÑ ÎØ∏ÏóÖÎ°úÎìú Ï∫°Ï≤ò Ïù¥ÎØ∏ÏßÄ ${result[0].count}Í∞ú Î∞úÍ≤¨. ÏûêÎèô ÏóÖÎ°úÎìú ÏãúÏûë...`);
                    axios.post(`${serverUrl}/api/captures/upload-to-dropbox`)
                        .catch(err => console.error('Ï∫°Ï≤ò ÏûêÎèô ÏóÖÎ°úÎìú ÏöîÏ≤≠ Ïã§Ìå®:', err));
                }
            }
        } catch (error) {
            console.error('‚ùå ÏòàÏïΩÎêú Î∞±ÏóÖ ÏûëÏóÖ Ï§ë Ïò§Î•ò:', error);
        }
    }, {
        timezone: 'Asia/Seoul'
    });
    
    // 12ÏãúÍ∞ÑÎßàÎã§ ÏÑúÎ≤Ñ ÌôúÏÑ±Ìôî ÌôïÏù∏
    cron.schedule('0 */12 * * *', async () => {
        const serverUrl = getServerUrl();
        console.log(`‚è∞ 12ÏãúÍ∞Ñ Ï£ºÍ∏∞ ÏÑúÎ≤Ñ ÌôúÏÑ±Ìôî ÌôïÏù∏ Ï§ë...`);
        
        try {
            await axios.get(`${serverUrl}/ping`);
            console.log('‚úÖ ÏÑúÎ≤Ñ ÌôúÏÑ±Ìôî ÌôïÏù∏ ÏôÑÎ£å');
        } catch (error) {
            console.error('‚ùå ÏÑúÎ≤Ñ ÌôúÏÑ±Ìôî ÌôïÏù∏ Ïã§Ìå®:', error.message);
        }
    }, {
        timezone: 'Asia/Seoul'
    });
});

// Í∏∞Î≥∏ ÎùºÏö∞Ìä∏
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'olive.html'));
});

app.get('/ping', (req, res) => {
    res.send('pong');
});

// API ÎùºÏö∞Ìä∏
app.get('/api/rankings', (req, res) => {
    const { category, date } = req.query;
    
    db.get(
        `SELECT updated_at FROM update_logs ORDER BY updated_at DESC LIMIT 1`,
        (err, lastCrawled) => {
            if (err) {
                console.error("ÎßàÏßÄÎßâ ÌÅ¨Î°§ÎßÅ ÏãúÍ∞Å Ï°∞Ìöå Ï§ë Ïò§Î•ò:", err);
                return res.status(500).json({ error: 'DB Ïò§Î•ò' });
            }

            db.all(
                `SELECT 
                    date,
                    rank,
                    brand,
                    product,
                    salePrice,
                    originalPrice,
                    event,
                    category,
                    ? as crawled_at
                FROM rankings 
                WHERE category = ? AND date = ?
                ORDER BY rank ASC`,
                [lastCrawled ? lastCrawled.updated_at : null, category, date],
                (err, rows) => {
                    if (err) {
                        console.error("DB ÏóêÎü¨:", err);
                        return res.status(500).json({ error: 'DB Ïò§Î•ò' });
                    }
                    res.json({ rankings: rows });
                }
            );
        }
    );
});

app.get('/api/search', (req, res) => {
    const { keyword } = req.query;
    if (!keyword) {
        return res.status(400).json({ error: 'Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.' });
    }
    db.all(
        `SELECT * FROM rankings WHERE product LIKE ?`,
        [`%${keyword}%`],
        (err, rows) => {
            if (err) {
                console.error("DB ÏóêÎü¨:", err);
                return res.status(500).json({ error: 'DB Ïò§Î•ò' });
            }
            res.json(rows);
        }
    );
});

app.get('/api/search-range', (req, res) => {
    const { keyword, startDate, endDate } = req.query;

    if (!keyword || !startDate || !endDate) {
        return res.status(400).json({ message: 'Ï†úÌíàÎ™ÖÍ≥º ÎÇ†Ïßú Î≤îÏúÑÎ•º Î™®Îëê ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.' });
    }

    const start = new Date(startDate);
    const end = new Date(endDate);
    if (isNaN(start) || isNaN(end)) {
        return res.status(400).json({ message: 'Ïú†Ìö®Ìïú ÎÇ†ÏßúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.' });
    }

    const formattedStartDate = start.toISOString().split('T')[0];
    const formattedEndDate = end.toISOString().split('T')[0];

    db.all(`
        WITH RankedResults AS (
            SELECT 
                date,
                category,
                CAST(rank AS INTEGER) as rank,
                brand,
                product,
                originalPrice,
                salePrice,
                event,
                ROW_NUMBER() OVER (
                    PARTITION BY date, product 
                    ORDER BY 
                        CASE 
                            WHEN category IN (
                                'Ïä§ÌÇ®ÏºÄÏñ¥', 'ÎßàÏä§ÌÅ¨Ìå©', 'ÌÅ¥Î†åÏßï', 'ÏÑ†ÏºÄÏñ¥', 'Î©îÏù¥ÌÅ¨ÏóÖ',
                                'ÎÑ§Ïùº', 'Î∑∞Ìã∞ÏÜåÌíà', 'ÎçîÎ™®_ÏΩîÏä§Î©îÌã±', 'Îß®Ï¶àÏºÄÏñ¥', 'Ìñ•Ïàò_ÎîîÌì®Ï†Ä',
                                'Ìó§Ïñ¥ÏºÄÏñ¥', 'Î∞îÎîîÏºÄÏñ¥', 'Í±¥Í∞ïÏãùÌíà', 'Ìë∏Îìú', 'Íµ¨Í∞ïÏö©Ìíà',
                                'Ìó¨Ïä§_Í±¥Í∞ïÏö©Ìíà', 'Ïó¨ÏÑ±_ÏúÑÏÉùÏö©Ìíà', 'Ìå®ÏÖò', 'Î¶¨Îπô_Í∞ÄÏ†Ñ', 'Ï∑®ÎØ∏_Ìå¨Ïãú'
                            ) THEN 0
                            ELSE 1
                        END,
                        CAST(rank AS INTEGER)
                ) as rn
            FROM rankings
            WHERE product LIKE ? 
            AND date BETWEEN ? AND ?
        )
        SELECT 
            date,
            category,
            rank,
            brand,
            product,
            originalPrice,
            salePrice,
            event
        FROM RankedResults
        WHERE rn = 1
        ORDER BY date ASC, CAST(rank AS INTEGER) ASC
    `, [`%${keyword}%`, formattedStartDate, formattedEndDate], (err, rows) => {
        if (err) {
            console.error("ÏÑúÎ≤Ñ Ïò§Î•ò:", err);
            return res.status(500).json({ error: 'ÏÑúÎ≤Ñ Ïò§Î•ò' });
        }
        res.json(rows);
    });
});

app.get('/api/rankings-range', (req, res) => {
    const { category, startDate, endDate } = req.query;

    if (!category || !startDate || !endDate) {
        return res.status(400).json({ error: 'Ïπ¥ÌÖåÍ≥†Î¶¨ÏôÄ ÎÇ†ÏßúÎ•º Î™®Îëê ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.' });
    }

    db.all(`
        SELECT date, rank, brand, product, salePrice, originalPrice, event, category
        FROM rankings
        WHERE category = ?
        AND date BETWEEN ? AND ?
        ORDER BY date ASC, rank ASC
    `, [category, startDate, endDate], (err, rows) => {
        if (err) {
            console.error("DB Ïò§Î•ò:", err);
            return res.status(500).json({ error: 'ÏÑúÎ≤Ñ Ïò§Î•ò' });
        }
        res.json(rows);
    });
});

app.get('/api/download', (req, res) => {
    const { category, startDate, endDate } = req.query;

    if (!category || !startDate || !endDate) {
        return res.status(400).json({ error: 'Ïπ¥ÌÖåÍ≥†Î¶¨ÏôÄ ÎÇ†Ïßú Î≤îÏúÑÎ•º Ï†ÑÎã¨Ìï¥Ïïº Ìï©ÎãàÎã§.' });
    }

    db.all(
        `SELECT 
            date,
            ? as category,
            CAST(rank AS INTEGER) as rank,
            brand,
            product,
            originalPrice,
            salePrice,
            event
        FROM rankings 
        WHERE category = ? AND date BETWEEN ? AND ?
        ORDER BY date ASC, CAST(rank AS INTEGER) ASC`,
        [category, category, startDate, endDate],
        (err, rows) => {
            if (err) {
                console.error('DB ÏóêÎü¨:', err);
                return res.status(500).json({ error: 'DB Ïò§Î•ò' });
            }

            const workbook = new ExcelJS.Workbook();
            const worksheet = workbook.addWorksheet('Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞');

            worksheet.columns = [
                { header: 'ÎÇ†Ïßú', key: 'date', width: 15 },
                { header: 'Ïπ¥ÌÖåÍ≥†Î¶¨', key: 'category', width: 15 },
                { header: 'ÏàúÏúÑ', key: 'rank', width: 6 },
                { header: 'Î∏åÎûúÎìú', key: 'brand', width: 15 },
                { header: 'Ï†úÌíàÎ™Ö', key: 'product', width: 60 },
                { header: 'ÏÜåÎπÑÏûêÍ∞Ä', key: 'originalPrice', width: 20 },
                { header: 'ÌåêÎß§Í∞Ä', key: 'salePrice', width: 20 },
                { header: 'ÌñâÏÇ¨', key: 'event', width: 40 }
            ];

            const processedRows = rows.map(row => ({
                ...row,
                brand: row.brand || '-',
                originalPrice: normalizePrice(row.originalPrice),
                salePrice: normalizePrice(row.salePrice),
                event: row.event || '-'
            }));

            worksheet.addRows(processedRows);

            worksheet.getRow(1).eachCell((cell) => {
                cell.font = { bold: true };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFEEEEEE' }
                };
                cell.alignment = { vertical: 'middle', horizontal: 'center' };
            });

            worksheet.eachRow((row) => {
                row.height = 20;
                row.alignment = { vertical: 'middle', wrapText: true };
            });

            const filename = `ranking_data_${startDate}~${endDate}.xlsx`;
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

            workbook.xlsx.write(res).then(() => {
                res.end();
            });
        }
    );
});

app.get('/api/download-search', (req, res) => {
    const { keyword, startDate, endDate } = req.query;
    if (!keyword || !startDate || !endDate) {
        return res.status(400).json({ error: 'Í≤ÄÏÉâÏñ¥ÏôÄ ÎÇ†Ïßú Î≤îÏúÑÎ•º Î™®Îëê ÏûÖÎ†•Ìï¥Ïïº Ìï©ÎãàÎã§.' });
    }
    db.all(
        `WITH RankedResults AS (
            SELECT 
                date,
                category,
                CAST(rank AS INTEGER) as rank,
                brand,
                product,
                originalPrice,
                salePrice,
                event,
                ROW_NUMBER() OVER (
                    PARTITION BY date, product 
                    ORDER BY 
                        CASE 
                            WHEN category IN (
                                'Ïä§ÌÇ®ÏºÄÏñ¥', 'ÎßàÏä§ÌÅ¨Ìå©', 'ÌÅ¥Î†åÏßï', 'ÏÑ†ÏºÄÏñ¥', 'Î©îÏù¥ÌÅ¨ÏóÖ',
                                'ÎÑ§Ïùº', 'Î∑∞Ìã∞ÏÜåÌíà', 'ÎçîÎ™®_ÏΩîÏä§Î©îÌã±', 'Îß®Ï¶àÏºÄÏñ¥', 'Ìñ•Ïàò_ÎîîÌì®Ï†Ä',
                                'Ìó§Ïñ¥ÏºÄÏñ¥', 'Î∞îÎîîÏºÄÏñ¥', 'Í±¥Í∞ïÏãùÌíà', 'Ìë∏Îìú', 'Íµ¨Í∞ïÏö©Ìíà',
                                'Ìó¨Ïä§_Í±¥Í∞ïÏö©Ìíà', 'Ïó¨ÏÑ±_ÏúÑÏÉùÏö©Ìíà', 'Ìå®ÏÖò', 'Î¶¨Îπô_Í∞ÄÏ†Ñ', 'Ï∑®ÎØ∏_Ìå¨Ïãú'
                            ) THEN 0
                            ELSE 1
                        END,
                        CAST(rank AS INTEGER)
                ) as rn
            FROM rankings
            WHERE product LIKE ? 
            AND date BETWEEN ? AND ?
        )
        SELECT 
            date,
            category,
            rank,
            brand,
            product,
            originalPrice,
            salePrice,
            event
        FROM RankedResults
        WHERE rn = 1
        ORDER BY date ASC, CAST(rank AS INTEGER) ASC`,
        [`%${keyword}%`, startDate, endDate],
        (err, rows) => {
            if (err) {
                console.error('DB ÏóêÎü¨:', err);
                return res.status(500).json({ error: 'DB Ïò§Î•ò' });
            }

            const workbook = new ExcelJS.Workbook();
            const worksheet = workbook.addWorksheet('Í≤ÄÏÉâ Í≤∞Í≥º');

            worksheet.columns = [
                { header: 'ÎÇ†Ïßú', key: 'date', width: 15 },
                { header: 'Ïπ¥ÌÖåÍ≥†Î¶¨', key: 'category', width: 15 },
                { header: 'ÏàúÏúÑ', key: 'rank', width: 6 },
                { header: 'Î∏åÎûúÎìú', key: 'brand', width: 15 },
                { header: 'Ï†úÌíàÎ™Ö', key: 'product', width: 60 },
                { header: 'ÏÜåÎπÑÏûêÍ∞Ä', key: 'originalPrice', width: 20 },
                { header: 'ÌåêÎß§Í∞Ä', key: 'salePrice', width: 20 },
                { header: 'ÌñâÏÇ¨', key: 'event', width: 40 }
            ];

            const processedRows = rows.map(row => ({
                ...row,
                category: row.category || 'ÎØ∏Î∂ÑÎ•ò',
                brand: row.brand || '-',
                originalPrice: normalizePrice(row.originalPrice),
                salePrice: normalizePrice(row.salePrice),
                event: row.event || '-'
            }));

            worksheet.addRows(processedRows);

            worksheet.getRow(1).eachCell((cell) => {
                cell.font = { bold: true };
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFEEEEEE' }
                };
                cell.alignment = { vertical: 'middle', horizontal: 'center' };
            });

            worksheet.eachRow((row) => {
                row.height = 20;
                row.alignment = { vertical: 'middle', wrapText: true };
            });

            const filename = `product_search_${startDate}~${endDate}.xlsx`;
            res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

            workbook.xlsx.write(res).then(() => {
                res.end();
            });
        }
    );
});

app.get('/api/crawl-all', async (req, res) => {
    console.log('üöÄ API Ìò∏Ï∂ú: Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨ ÌÅ¨Î°§ÎßÅ ÏãúÏûë');
    try {
        await crawlAllCategories();
        res.json({ success: true, message: 'Î™®Îì† Ïπ¥ÌÖåÍ≥†Î¶¨ ÌÅ¨Î°§ÎßÅÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.' });
    } catch (error) {
        console.error('‚ùå API ÌÅ¨Î°§ÎßÅ Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
        res.status(500).json({ success: false, error: 'ÌÅ¨Î°§ÎßÅ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' });
    }
});

// Ï∫°Ï≤ò Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
const capturesDir = path.join(__dirname, 'public', 'captures');
if (!fs.existsSync(capturesDir)) {
    fs.mkdirSync(capturesDir, { recursive: true });
}

// Dropbox ÌÜ†ÌÅ∞ Í∞±Ïã†
async function refreshDropboxToken() {
    if (!process.env.DROPBOX_REFRESH_TOKEN || !process.env.DROPBOX_CLIENT_ID || !process.env.DROPBOX_CLIENT_SECRET) {
        console.error('‚ùå Dropbox ÌÜ†ÌÅ∞ Í∞±Ïã†Ïóê ÌïÑÏöîÌïú ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏóÜÏäµÎãàÎã§.');
        return false;
    }

    try {
        const response = await axios.post('https://api.dropbox.com/oauth2/token', null, {
            params: {
                grant_type: 'refresh_token',
                refresh_token: process.env.DROPBOX_REFRESH_TOKEN,
                client_id: process.env.DROPBOX_CLIENT_ID,
                client_secret: process.env.DROPBOX_CLIENT_SECRET
            }
        });

        if (response.data && response.data.access_token) {
            dropboxClient = new Dropbox({
                accessToken: response.data.access_token,
                refreshToken: process.env.DROPBOX_REFRESH_TOKEN,
                clientId: process.env.DROPBOX_CLIENT_ID,
                clientSecret: process.env.DROPBOX_CLIENT_SECRET
            });
            console.log('‚úÖ Dropbox ÌÜ†ÌÅ∞Ïù¥ Í∞±Ïã†ÎêòÏóàÏäµÎãàÎã§.');
            return true;
        }
    } catch (error) {
        console.error('‚ùå Dropbox ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå®:', error.message);
        return false;
    }
    return false;
}

// Dropbox API Ìò∏Ï∂ú Ï†Ñ ÌÜ†ÌÅ∞ ÌôïÏù∏ Î∞è Í∞±Ïã†
async function ensureValidDropboxToken() {
    if (!dropboxClient) return false;
    
    try {
        await dropboxClient.filesListFolder({ path: '' });
        return true;
    } catch (error) {
        if (error.status === 401) {
            return await refreshDropboxToken();
        }
        throw error;
    }
}

// DropboxÏóê Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
async function uploadImageToDropbox(localFilePath, fileName, category) {
    if (!dropboxClient) {
        console.warn('‚ö†Ô∏è Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìúÎ•º Í±¥ÎÑàÎúÅÎãàÎã§.');
        return null;
    }
    
    try {
        await ensureValidDropboxToken();
        
        const now = new Date();
        const yearMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        const dropboxFilePath = `${DROPBOX_CAPTURES_PATH}/${yearMonth}/${category}/${fileName}`;
        
        console.log(`üîÑ DropboxÏóê Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ï§ë: ${dropboxFilePath}`);
        
        const fileContent = fs.readFileSync(localFilePath);
        
        const response = await dropboxClient.filesUpload({
            path: dropboxFilePath,
            contents: fileContent,
            mode: {'.tag': 'overwrite'}
        });
        
        console.log(`‚úÖ Dropbox Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏôÑÎ£å: ${dropboxFilePath}`);
        return dropboxFilePath;
    } catch (error) {
        console.error('‚ùå Dropbox Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®:', error.message);
        return null;
    }
}

// Ï∫°Ï≤ò API
app.post('/api/capture', async (req, res) => {
    const { html, category, date } = req.body;
    if (!html || !category || !date) {
        return res.status(400).json({ error: 'ÌïÑÏàò Îç∞Ïù¥ÌÑ∞Í∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§.' });
    }

    try {
        const browser = await puppeteer.launch({
            executablePath: CHROME_PATH,
            headless: 'new',
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        const page = await browser.newPage();
        
        await page.setContent(html);
        await page.addStyleTag({
            content: `
                body { 
                    background: white;
                    padding: 20px;
                }
                table {
                    width: 100%;
                    border-collapse: collapse;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #f5f5f5;
                }
            `
        });

        const bodyHandle = await page.$('body');
        const { height } = await bodyHandle.boundingBox();
        await bodyHandle.dispose();

        await page.setViewport({
            width: 1200,
            height: Math.ceil(height)
        });

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `capture_${category}_${date}_${timestamp}.png`;
        const filepath = path.join(capturesDir, filename);
        
        await page.screenshot({
            path: filepath,
            fullPage: true
        });

        await browser.close();

        let dropboxPath = null;
        if (dropboxClient) {
            dropboxPath = await uploadImageToDropbox(filepath, filename, category);
        }

        await new Promise((resolve, reject) => {
            db.run(
                `INSERT INTO captures (filename, category, capture_date, dropbox_path, created_at) 
                VALUES (?, ?, ?, ?, datetime('now', 'localtime'))`,
                [filename, category, date, dropboxPath],
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });

        res.json({ 
            success: true, 
            filename,
            url: `/captures/${filename}`,
            dropbox_path: dropboxPath
        });

    } catch (error) {
        console.error('Ï∫°Ï≤ò Ï§ë Ïò§Î•ò:', error);
        res.status(500).json({ error: 'Ï∫°Ï≤ò ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' });
    }
});

// Í∏∞Ï°¥ Ï∫°Ï≤ò Ïù¥ÎØ∏ÏßÄÎ•º DropboxÏóê ÏóÖÎ°úÎìú
app.post('/api/captures/upload-to-dropbox', async (req, res) => {
    if (!dropboxClient) {
        return res.status(400).json({ 
            success: false, 
            error: 'Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Íµ¨ÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.' 
        });
    }
    
    try {
        const captures = await dbAll(`
            SELECT id, filename, category, capture_date
            FROM captures
            WHERE dropbox_path IS NULL
        `);
        
        if (captures.length === 0) {
            return res.json({
                success: true,
                message: 'DropboxÏóê ÏóÖÎ°úÎìúÌï† Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§.',
                uploaded: 0
            });
        }
        
        let successCount = 0;
        
        for (const capture of captures) {
            const localFilePath = path.join(capturesDir, capture.filename);
            
            if (!fs.existsSync(localFilePath)) {
                console.warn(`ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${localFilePath}`);
                continue;
            }
            
            const dropboxPath = await uploadImageToDropbox(
                localFilePath, 
                capture.filename, 
                capture.category
            );
            
            if (dropboxPath) {
                await dbRun(
                    `UPDATE captures SET dropbox_path = ? WHERE id = ?`,
                    [dropboxPath, capture.id]
                );
                successCount++;
            }
        }
        
        res.json({
            success: true,
            message: `${successCount}/${captures.length} Í∞úÏùò Ïù¥ÎØ∏ÏßÄÍ∞Ä DropboxÏóê ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§.`,
            uploaded: successCount,
            total: captures.length
        });
        
    } catch (error) {
        console.error('‚ùå Í∏∞Ï°¥ Ï∫°Ï≤ò ÏóÖÎ°úÎìú Ï§ë Ïò§Î•ò:', error);
        res.status(500).json({
            success: false,
            error: `Ï∫°Ï≤ò ÏóÖÎ°úÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`
        });
    }
});

// Ï∫°Ï≤ò Î™©Î°ù Ï°∞Ìöå
app.get('/api/captures', (req, res) => {
    const { category, startDate, endDate } = req.query;
    let query = `SELECT * FROM captures`;
    const params = [];

    if (category || (startDate && endDate)) {
        query += ` WHERE 1=1`;
        if (category) {
            query += ` AND category = ?`;
            params.push(category);
        }
        if (startDate && endDate) {
            query += ` AND capture_date BETWEEN ? AND ?`;
            params.push(startDate, endDate);
        }
    }

    query += ` ORDER BY created_at DESC`;

    db.all(query, params, (err, rows) => {
        if (err) {
            console.error('Ï∫°Ï≤ò Î™©Î°ù Ï°∞Ìöå Ïò§Î•ò:', err);
            return res.status(500).json({ error: 'DB Ïò§Î•ò' });
        }
        res.json(rows);
    });
});

// ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏
app.get('/api/status', (req, res) => {
    try {
        const serverInfo = {
            status: 'running',
            uptime: process.uptime() + ' seconds',
            timestamp: new Date().toISOString()
        };
        
        db.all("SELECT name FROM sqlite_master WHERE type='table'", (err, tables) => {
            if (err) {
                return res.status(500).json({
                    ...serverInfo,
                    db_status: 'error',
                    error: err.message
                });
            }
            
            db.get("SELECT COUNT(*) as count FROM rankings", (err, countResult) => {
                if (err) {
                    return res.status(500).json({
                        ...serverInfo,
                        db_status: 'error',
                        tables,
                        error: err.message
                    });
                }
                
                db.get("SELECT updated_at FROM update_logs ORDER BY updated_at DESC LIMIT 1", (err, updateLog) => {
                    const responseData = {
                        ...serverInfo,
                        db_status: 'connected',
                        tables: tables.map(t => t.name),
                        rankings_count: countResult ? countResult.count : 0,
                    };
                    
                    res.json(responseData);
                });
            });
        });
    } catch (error) {
        res.status(500).json({
            status: 'error',
            error: error.message
        });
    }
});

// Î∞±ÏóÖ Í¥ÄÎ¶¨
app.get('/api/backups', async (req, res) => {
    try {
        const logs = await dbAll(
            `SELECT * FROM backup_logs ORDER BY created_at DESC LIMIT 100`
        );
        
        res.json({
            success: true,
            backups: logs
        });
    } catch (error) {
        console.error('Î∞±ÏóÖ Î°úÍ∑∏ Ï°∞Ìöå Ïò§Î•ò:', error);
        res.status(500).json({
            success: false,
            error: 'Î∞±ÏóÖ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
        });
    }
});

// ÏàòÎèô Î∞±ÏóÖ
app.post('/api/backup', async (req, res) => {
    try {
        const result = await backupDatabase();
        if (result) {
            res.json({
                success: true,
                message: 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î∞±ÏóÖÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.'
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Î∞±ÏóÖ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
            });
        }
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// DropboxÏóêÏÑú ÏµúÏã† Î∞±ÏóÖ Î≥µÏõê
app.post('/api/restore', async (req, res) => {
    if (!dropboxClient) {
        return res.status(400).json({
            success: false,
            error: 'Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Íµ¨ÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.'
        });
    }
    
    try {
        const tempBackupPath = path.join(DB_BACKUP_DIR, `pre_restore_${Date.now()}.db`);
        fs.copyFileSync(DB_MAIN_FILE, tempBackupPath);
        
        const { result } = await dropboxClient.filesListFolder({
            path: '/olive_rankings/backup'
        });
        
        if (!result.entries || result.entries.length === 0) {
            return res.status(404).json({
                success: false,
                error: 'DropboxÏóê Î∞±ÏóÖ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.'
            });
        }
        
        const backupFiles = result.entries
            .filter(entry => entry.name.startsWith('rankings_') && entry.name.endsWith('.db'))
            .sort((a, b) => b.name.localeCompare(a.name));
        
        if (backupFiles.length === 0) {
            return res.status(404).json({
                success: false,
                error: 'Ïú†Ìö®Ìïú Î∞±ÏóÖ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
            });
        }
        
        const latestBackup = backupFiles[0];
        console.log(`üîÑ ÏµúÏã† Î∞±ÏóÖ ÌååÏùºÏóêÏÑú Î≥µÏõê Ï§ë: ${latestBackup.name}`);
        
        const tempPath = path.join(DB_BACKUP_DIR, `temp_${Date.now()}.db`);
        const downloadResponse = await dropboxClient.filesDownload({
            path: latestBackup.path_lower
        });
        
        fs.writeFileSync(tempPath, downloadResponse.result.fileBinary);
        
        await new Promise(resolve => {
            db.close(err => {
                if (err) console.error('DB Ïó∞Í≤∞ Ï¢ÖÎ£å Ï§ë Ïò§Î•ò:', err);
                resolve();
            });
        });
        
        fs.copyFileSync(tempPath, DB_MAIN_FILE);
        fs.unlinkSync(tempPath);
        
        const newDb = new sqlite3.Database(DB_MAIN_FILE, err => {
            if (err) {
                console.error('DB Ïû¨Ïó∞Í≤∞ Ïò§Î•ò:', err);
                return res.status(500).json({
                    success: false,
                    error: 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïû¨Ïó∞Í≤∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
                });
            }
            
            global.db = newDb;
            
            res.json({
                success: true,
                message: `Î∞±ÏóÖ ÌååÏùº '${latestBackup.name}'ÏóêÏÑú ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î≥µÏõêÎêòÏóàÏäµÎãàÎã§.`,
                backup: latestBackup
            });
        });
    } catch (error) {
        console.error('Î≥µÏõê Ï§ë Ïò§Î•ò:', error);
        res.status(500).json({
            success: false,
            error: `Î≥µÏõê Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`
        });
    }
});

// Dropbox Î∞±ÏóÖ ÌååÏùº Î™©Î°ù Ï°∞Ìöå
app.get('/api/backup-files', async (req, res) => {
    if (!dropboxClient) {
        return res.status(400).json({
            success: false,
            error: 'Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Íµ¨ÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.'
        });
    }
    
    try {
        const { result } = await dropboxClient.filesListFolder({
            path: '/olive_rankings/backup'
        });
        
        const backupFiles = result.entries
            .filter(entry => entry.name.startsWith('rankings_') && entry.name.endsWith('.db'))
            .sort((a, b) => b.name.localeCompare(a.name));
        
        res.json({
            success: true,
            files: backupFiles
        });
    } catch (error) {
        console.error('Î∞±ÏóÖ ÌååÏùº Î™©Î°ù Ï°∞Ìöå Ïò§Î•ò:', error);
        res.status(500).json({
            success: false,
            error: 'Î∞±ÏóÖ ÌååÏùº Î™©Î°ùÏùÑ Ï°∞ÌöåÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
        });
    }
});

// ÌäπÏ†ï Î∞±ÏóÖ ÌååÏùº Î≥µÏõê
app.post('/api/restore-backup', async (req, res) => {
    const { filePath } = req.body;
    
    if (!dropboxClient) {
        return res.status(400).json({
            success: false,
            error: 'Dropbox ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Íµ¨ÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.'
        });
    }
    
    if (!filePath) {
        return res.status(400).json({
            success: false,
            error: 'Î≥µÏõêÌï† Î∞±ÏóÖ ÌååÏùº Í≤ΩÎ°úÎ•º ÏßÄÏ†ïÌï¥Ï£ºÏÑ∏Ïöî.'
        });
    }
    
    try {
        const tempBackupPath = path.join(DB_BACKUP_DIR, `pre_restore_${Date.now()}.db`);
        fs.copyFileSync(DB_MAIN_FILE, tempBackupPath);
        
        const downloadResponse = await dropboxClient.filesDownload({
            path: filePath
        });
        
        const tempPath = path.join(DB_BACKUP_DIR, `temp_${Date.now()}.db`);
        fs.writeFileSync(tempPath, downloadResponse.result.fileBinary);
        
        await new Promise(resolve => {
            db.close(err => {
                if (err) console.error('DB Ïó∞Í≤∞ Ï¢ÖÎ£å Ï§ë Ïò§Î•ò:', err);
                resolve();
            });
        });
        
        fs.copyFileSync(tempPath, DB_MAIN_FILE);
        fs.unlinkSync(tempPath);
        
        const newDb = new sqlite3.Database(DB_MAIN_FILE, err => {
            if (err) {
                console.error('DB Ïû¨Ïó∞Í≤∞ Ïò§Î•ò:', err);
                return res.status(500).json({
                    success: false,
                    error: 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïû¨Ïó∞Í≤∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
                });
            }
            
            global.db = newDb;
            
            res.json({
                success: true,
                message: `Î∞±ÏóÖ ÌååÏùº '${filePath}'ÏóêÏÑú ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î≥µÏõêÎêòÏóàÏäµÎãàÎã§.`
            });
        });
    } catch (error) {
        console.error('Î≥µÏõê Ï§ë Ïò§Î•ò:', error);
        res.status(500).json({
            success: false,
            error: `Î≥µÏõê Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`
        });
    }
});

// ÏÑúÎ≤Ñ Íπ®Ïö∞Í∏∞
app.get('/api/wake-up', async (req, res) => {
    const timestamp = new Date().toISOString();
    console.log(`üîî Wake-up ÏöîÏ≤≠ Î∞õÏùå: ${timestamp}`);
    
    try {
        const serverStatus = {
            timestamp,
            uptime: process.uptime() + 'Ï¥à',
            memory: process.memoryUsage()
        };
        
        res.json({
            success: true,
            message: 'ÏÑúÎ≤ÑÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.',
            status: serverStatus
        });
        
        if (req.query.run_tasks === 'true') {
            console.log('üîÑ Wake-up ÏöîÏ≤≠ÏúºÎ°ú Ïù∏Ìïú ÏûêÎèô ÏûëÏóÖ ÏàòÌñâ Ï§ë...');
            setTimeout(() => {
                backupDatabase().catch(err => console.error('ÏûêÎèô Î∞±ÏóÖ Ïò§Î•ò:', err));
            }, 5000);
        }
    } catch (error) {
        console.error('Wake-up Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:', error);
        res.status(500).json({
            success: false,
            error: 'ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
        });
    }
});